<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of optimizeProb</title>
  <meta name="keywords" content="optimizeProb">
  <meta name="description" content="optimizeProb">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">solver</a> &gt; optimizeProb.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for solver&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>optimizeProb
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>optimizeProb</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function res = optimizeProb(prob,params,verbose) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> optimizeProb
   Optimize an LP or MILP formulated in cobra terms.

   prob    cobra style LP/MILP problem struct to be optimised
   params    solver specific parameters (optional)
   verbose if true MILP progress is shown (opt, default true)

   res        the output structure from the selected solver RAVENSOLVER
           (cobra style)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="solveLP.html" class="code" title="function [solution, hsSolOut]=solveLP(model,minFlux,params,hsSol)">solveLP</a>	solveLP</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function s_merged=structUpdate(s_old,s_new)</a></li><li><a href="#_sub2" class="code">function paramlist = renameparams(paramlist,old,new)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function res = optimizeProb(prob,params,verbose)</a>
0002 <span class="comment">% optimizeProb</span>
0003 <span class="comment">%   Optimize an LP or MILP formulated in cobra terms.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%   prob    cobra style LP/MILP problem struct to be optimised</span>
0006 <span class="comment">%   params    solver specific parameters (optional)</span>
0007 <span class="comment">%   verbose if true MILP progress is shown (opt, default true)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   res        the output structure from the selected solver RAVENSOLVER</span>
0010 <span class="comment">%           (cobra style)</span>
0011 
0012 <span class="keyword">if</span> nargin&lt;2 || isempty(params)
0013     params=struct();
0014 <span class="keyword">end</span>
0015 <span class="keyword">if</span> nargin&lt;3 || isempty(verbose)
0016     verbose = true;
0017 <span class="keyword">end</span>
0018 <span class="comment">%Set as global variable for speed improvement if optimizeProb is run many times</span>
0019 <span class="keyword">global</span> RAVENSOLVER;
0020 <span class="keyword">if</span> isempty(RAVENSOLVER)
0021     <span class="keyword">if</span>(~ispref(<span class="string">'RAVEN'</span>,<span class="string">'solver'</span>))
0022         dispEM(<span class="string">'RAVEN solver not defined or unknown. Try using setRavenSolver(''solver'').'</span>);
0023     <span class="keyword">else</span>
0024         RAVENSOLVER = getpref(<span class="string">'RAVEN'</span>,<span class="string">'solver'</span>);
0025     <span class="keyword">end</span>
0026 <span class="keyword">end</span>
0027 solver=RAVENSOLVER;
0028 
0029 
0030 
0031 <span class="keyword">if</span> ~all(lower(prob.vartype) == <span class="string">'c'</span>)
0032     disp(<span class="string">'MILP detected.'</span>);
0033     milp=true;
0034 <span class="keyword">else</span>
0035     milp=false;
0036 <span class="keyword">end</span>
0037 
0038 <span class="comment">%% Define default parameters, which will then be used to make solver-</span>
0039 <span class="comment">% specific solverparams structures</span>
0040 defaultparams.feasTol        = 1e-9;
0041 defaultparams.optTol         = 1e-9;
0042 defaultparams.objTol         = 1e-6;
0043 defaultparams.timeLimit      = 1000;
0044 <span class="comment">%defaultparams.iterationLimit = 1000;</span>
0045 defaultparams.intTol         = 1e-12;
0046 defaultparams.relMipGapTol   = 1e-12;
0047 defaultparams.absMipGapTol   = 1e-12;
0048 <span class="keyword">if</span> milp
0049     defaultparams.MIPGap     = 1e-12; 
0050     defaultparams.Seed       = 1;
0051 <span class="keyword">end</span>
0052 
0053 <span class="keyword">switch</span> solver
0054     <span class="comment">%% Use whatever solver is set by COBRA Toolbox changeCobraSolver</span>
0055     <span class="keyword">case</span> <span class="string">'cobra'</span>
0056         <span class="keyword">if</span> milp
0057             cparams=struct(<span class="string">'timeLimit'</span>,1e9,<span class="string">'printLevel'</span>,0,<span class="string">'intTol'</span>,1e-6,<span class="string">'relMipGapTol'</span>,1e-9);
0058             cparams=<a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(cparams,params);
0059             res=solveCobraMILP(prob,cparams);
0060         <span class="keyword">else</span>
0061             res=solveCobraLP(prob);
0062         <span class="keyword">end</span>
0063         
0064     <span class="comment">%% Use Gurobi in a MATLAB environment</span>
0065     <span class="keyword">case</span> <span class="string">'gurobi'</span>
0066     <span class="keyword">if</span> milp
0067         <span class="keyword">if</span> verbose
0068             solverparams.OutputFlag = 1;
0069         <span class="keyword">else</span>
0070             solverparams.OutputFlag = 0;
0071         <span class="keyword">end</span>
0072         solverparams.intTol = 10^-9; <span class="comment">%min val for gurobi</span>
0073         solverparams.MIPGap = defaultparams.MIPGap;
0074         solverparams.Seed = defaultparams.Seed;
0075     <span class="keyword">else</span>
0076         solverparams.OutputFlag = 0;
0077     <span class="keyword">end</span>
0078     solverparams.DisplayInterval= 1; <span class="comment">% Level of verbosity</span>
0079     solverparams.TimeLimit      = defaultparams.timeLimit;
0080     solverparams.FeasibilityTol = defaultparams.feasTol;
0081     solverparams.OptimalityTol  = defaultparams.optTol;
0082     solverparams.Presolve       = 2;
0083     solverparams = <a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(solverparams,params);
0084     
0085     <span class="comment">% Restructering problem according to gurobi format</span>
0086     <span class="keyword">if</span> isfield(prob, <span class="string">'csense'</span>)
0087         prob.csense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(prob.csense, {<span class="string">'L'</span>,<span class="string">'G'</span>,<span class="string">'E'</span>}, {<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'='</span>});
0088         prob.sense = prob.csense;
0089         prob = rmfield(prob, {<span class="string">'csense'</span>});
0090     <span class="keyword">end</span>
0091     <span class="keyword">if</span> isfield(prob, <span class="string">'osense'</span>)
0092         prob.osense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(num2str(prob.osense), {<span class="string">'1'</span>,<span class="string">'-1'</span>}, {<span class="string">'min'</span>,<span class="string">'max'</span>});
0093         prob.modelsense = prob.osense;
0094         prob = rmfield(prob, {<span class="string">'osense'</span>});
0095     <span class="keyword">end</span>
0096     [prob.obj, prob.rhs] = deal(prob.c, prob.b);
0097     prob = rmfield(prob, {<span class="string">'c'</span>,<span class="string">'b'</span>});
0098     
0099     <span class="comment">%Rename intTol to IntFeasTol</span>
0100     <span class="keyword">if</span> milp
0101         solverparams.IntFeasTol = solverparams.intTol;
0102         solverparams  = rmfield(solverparams, {<span class="string">'intTol'</span>});
0103         prob.vtype = prob.vartype;
0104         prob  = rmfield(prob, {<span class="string">'vartype'</span>});
0105     <span class="keyword">end</span>
0106     
0107     resG = gurobi(prob,solverparams);
0108     
0109     <span class="keyword">try</span>
0110         [res.full, res.obj, res.origStat] = deal(resG.x,  resG.objval, resG.status);
0111         <span class="keyword">if</span> milp &amp;&amp; strcmp(resG.status, <span class="string">'TIME_LIMIT'</span>)
0112             <span class="comment">% If res has the objval field, it succeeded, regardless of</span>
0113             <span class="comment">% time_limit status</span>
0114             resG.status = <span class="string">'OPTIMAL'</span>;
0115         <span class="keyword">end</span>
0116         <span class="keyword">switch</span> resG.status
0117             <span class="keyword">case</span> <span class="string">'OPTIMAL'</span>
0118                 res.stat = 1;
0119             <span class="keyword">case</span> <span class="string">'UNBOUNDED'</span>
0120                 res.stat = 2;
0121             <span class="keyword">otherwise</span>
0122                 res.stat = 0;
0123         <span class="keyword">end</span>
0124         <span class="keyword">if</span> ~milp
0125             [res.vbasis, res.cbasis] = deal(resG.vbasis, resG.cbasis);
0126         <span class="keyword">else</span>
0127             res.mipgap = resG.mipgap; 
0128         <span class="keyword">end</span>
0129     <span class="keyword">catch</span>
0130         res.stat = 0;
0131         res.origStat = resG.status;  <span class="comment">% useful information to have</span>
0132     <span class="keyword">end</span>
0133     <span class="comment">%% Use GLPK using RAVEN-provided binary</span>
0134     <span class="keyword">case</span> <span class="string">'glpk'</span>
0135         solverparams.scale   = 128; <span class="comment">% Auto scaling</span>
0136         solverparams.tmlim   = defaultparams.timeLimit;
0137         solverparams.tolbnd  = defaultparams.feasTol;
0138         solverparams.toldj   = defaultparams.optTol;
0139         solverparams.tolint  = defaultparams.intTol;
0140         solverparams.tolobj  = defaultparams.objTol;
0141         solverparams.msglev  = 0; <span class="comment">% Level of verbosity</span>
0142         solverparams = <a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(solverparams,params);
0143         
0144         prob.csense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(prob.csense, {<span class="string">'L'</span>,<span class="string">'G'</span>,<span class="string">'E'</span>}, {<span class="string">'U'</span>,<span class="string">'L'</span>,<span class="string">'S'</span>});
0145         
0146         <span class="keyword">if</span> milp
0147             solverparams.tmlim   = solverparams.tmlim*10;
0148             solverparams.msglev  = 1; <span class="comment">% Level of verbosity</span>
0149             disp(<span class="string">'Issues have been observed when using GLPK for MILP solving. Be advised to carefully observe the results, or us another solver.'</span>)
0150         <span class="keyword">end</span>
0151         solverparams.scale   = 1; <span class="comment">% Auto scaling</span>
0152         
0153         <span class="comment">% Ensure that RAVEN glpk binary is used, return to original</span>
0154         <span class="comment">% directory afterwards</span>
0155         [ravenDir,currDir]=findRAVENroot();
0156         cd(fullfile(ravenDir,<span class="string">'software'</span>,<span class="string">'GLPKmex'</span>))
0157         [xopt, fmin, errnum, extra] = glpk(prob.c, prob.A, prob.b, prob.lb, prob.ub, prob.csense, prob.vartype, prob.osense, solverparams);
0158         cd(currDir)
0159         
0160         <span class="keyword">switch</span> errnum <span class="comment">% 1 = undefined; 2 = feasible; 3 = infeasible; 4 = no feasible solution; 5 = optimal; 6 = no unbounded solution</span>
0161             <span class="keyword">case</span> 5
0162                 res.stat = 1; <span class="comment">% Optimal</span>
0163             <span class="keyword">case</span> 2
0164                 res.stat = 2; <span class="comment">% Feasible, but not optimal</span>
0165             <span class="keyword">otherwise</span>
0166                 res.stat = 0;
0167         <span class="keyword">end</span>
0168         res.origStat = errnum;
0169         res.full     = xopt;
0170         res.obj      = fmin;
0171     <span class="keyword">otherwise</span>
0172         error(<span class="string">'RAVEN solver not defined or unknown. Try using setRavenSolver(''solver'').'</span>);
0173 <span class="keyword">end</span>
0174 <span class="keyword">if</span> res.stat&gt;0
0175     res.full=res.full(1:size(prob.a,2));
0176 <span class="keyword">end</span>
0177 <span class="keyword">end</span>
0178 
0179 <a name="_sub1" href="#_subfunctions" class="code">function s_merged=structUpdate(s_old,s_new)</a>
0180 <span class="comment">%Remove overlapping fields from first struct;</span>
0181 <span class="comment">%Obtain all unique names of remaining fields;</span>
0182 <span class="comment">%Merge both structs</span>
0183 s_merged = rmfield(s_old, intersect(fieldnames(s_old), fieldnames(s_new)));
0184 names = [fieldnames(s_merged); fieldnames(s_new)];
0185 s_merged = cell2struct([struct2cell(s_merged); struct2cell(s_new)], names, 1);
0186 <span class="keyword">end</span>
0187 
0188 <a name="_sub2" href="#_subfunctions" class="code">function paramlist = renameparams(paramlist,old,new)</a>
0189 <span class="keyword">if</span> ~iscell(paramlist)
0190     wasNoCell = true;
0191     paramlist={paramlist};
0192 <span class="keyword">else</span>
0193     wasNoCell = false;
0194 <span class="keyword">end</span>
0195 <span class="keyword">for</span> i=1:numel(old)
0196     paramlist = regexprep(paramlist,old{i},new{i});
0197 <span class="keyword">end</span>
0198 <span class="keyword">if</span> wasNoCell
0199     paramlist=paramlist{1};
0200 <span class="keyword">end</span>
0201 <span class="keyword">end</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>