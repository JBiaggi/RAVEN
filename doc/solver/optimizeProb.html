<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of optimizeProb</title>
  <meta name="keywords" content="optimizeProb">
  <meta name="description" content="optimizeProb">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">solver</a> &gt; optimizeProb.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for solver&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>optimizeProb
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>optimizeProb</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function res = optimizeProb(prob,params,verbose) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> optimizeProb
   Optimize an LP or MILP formulated in cobra terms.

   prob    cobra style LP/MILP problem struct to be optimised
   params    solver specific parameters (optional)
   verbose if true MILP progress is shown (opt, default true)

   res        the output structure from the selected solver RAVENSOLVER
           (cobra style)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="solveLP.html" class="code" title="function [solution, hsSolOut]=solveLP(model,minFlux,params,hsSol)">solveLP</a>	solveLP</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function s_merged=structUpdate(s_old,s_new)</a></li><li><a href="#_sub2" class="code">function paramlist = renameparams(paramlist,old,new)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function res = optimizeProb(prob,params,verbose)</a>
0002 <span class="comment">% optimizeProb</span>
0003 <span class="comment">%   Optimize an LP or MILP formulated in cobra terms.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%   prob    cobra style LP/MILP problem struct to be optimised</span>
0006 <span class="comment">%   params    solver specific parameters (optional)</span>
0007 <span class="comment">%   verbose if true MILP progress is shown (opt, default true)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   res        the output structure from the selected solver RAVENSOLVER</span>
0010 <span class="comment">%           (cobra style)</span>
0011 
0012 <span class="keyword">if</span> nargin&lt;2 || isempty(params)
0013     params=struct();
0014 <span class="keyword">end</span>
0015 <span class="keyword">if</span> nargin&lt;3 || isempty(verbose)
0016     verbose = true;
0017 <span class="keyword">end</span>
0018 <span class="keyword">if</span>(~ispref(<span class="string">'RAVEN'</span>,<span class="string">'solver'</span>))
0019     dispEM(<span class="string">'RAVEN solver not defined or unknown. Try using setRavenSolver(''solver'').'</span>);
0020 <span class="keyword">end</span>
0021 <span class="keyword">if</span> ~all(lower(prob.vartype) == <span class="string">'c'</span>)
0022     disp(<span class="string">'MILP detected.'</span>);
0023     milp=true;
0024 <span class="keyword">else</span>
0025     milp=false;
0026 <span class="keyword">end</span>
0027 
0028 <span class="comment">%% Define default parameters, which will then be used to make solver-</span>
0029 <span class="comment">% specific solverparams structures</span>
0030 defaultparams.feasTol        = 1e-9;
0031 defaultparams.optTol         = 1e-9;
0032 defaultparams.objTol         = 1e-9;
0033 defaultparams.timeLimit      = 1000;
0034 <span class="comment">%defaultparams.iterationLimit = 1000;</span>
0035 defaultparams.intTol         = 1e-12;
0036 defaultparams.relMipGapTol   = 1e-12;
0037 defaultparams.absMipGapTol   = 1e-12;
0038 <span class="keyword">if</span> milp
0039     defaultparams.MIPGap     = 1e-12; 
0040     defaultparams.Seed       = 1;
0041 <span class="keyword">end</span>
0042 solver=getpref(<span class="string">'RAVEN'</span>,<span class="string">'solver'</span>);
0043 
0044 <span class="keyword">switch</span> solver
0045     <span class="comment">%% Use whatever solver is set by COBRA Toolbox changeCobraSolver</span>
0046     <span class="keyword">case</span> <span class="string">'cobra'</span>
0047         <span class="keyword">if</span> milp
0048             cparams=struct(<span class="string">'timeLimit'</span>,1e9,<span class="string">'printLevel'</span>,0,<span class="string">'intTol'</span>,1e-6,<span class="string">'relMipGapTol'</span>,1e-9);
0049             cparams=<a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(cparams,params);
0050             res=solveCobraMILP(prob,cparams);
0051         <span class="keyword">else</span>
0052             res=solveCobraLP(prob);
0053         <span class="keyword">end</span>
0054         
0055     <span class="comment">%% Use Gurobi in a MATLAB environment</span>
0056     <span class="keyword">case</span> <span class="string">'gurobi'</span>
0057     <span class="keyword">if</span> milp
0058         <span class="keyword">if</span> verbose
0059             solverparams.OutputFlag = 1;
0060         <span class="keyword">else</span>
0061             solverparams.OutputFlag = 0;
0062         <span class="keyword">end</span>
0063         solverparams.intTol = 10^-9; <span class="comment">%min val for gurobi</span>
0064         solverparams.MIPGap = defaultparams.MIPGap;
0065         solverparams.Seed = defaultparams.Seed;
0066     <span class="keyword">else</span>
0067         solverparams.OutputFlag = 0;
0068     <span class="keyword">end</span>
0069     solverparams.DisplayInterval= 1; <span class="comment">% Level of verbosity</span>
0070     solverparams.TimeLimit      = defaultparams.timeLimit;
0071     solverparams.FeasibilityTol = defaultparams.feasTol;
0072     solverparams.OptimalityTol  = defaultparams.optTol;
0073     solverparams.Presolve       = 2;
0074     solverparams = <a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(solverparams,params);
0075     
0076     <span class="comment">% Restructering problem according to gurobi format</span>
0077     <span class="keyword">if</span> isfield(prob, <span class="string">'csense'</span>)
0078         prob.csense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(prob.csense, {<span class="string">'L'</span>,<span class="string">'G'</span>,<span class="string">'E'</span>}, {<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'='</span>});
0079         prob.sense = prob.csense;
0080         prob = rmfield(prob, {<span class="string">'csense'</span>});
0081     <span class="keyword">end</span>
0082     <span class="keyword">if</span> isfield(prob, <span class="string">'osense'</span>)
0083         prob.osense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(num2str(prob.osense), {<span class="string">'1'</span>,<span class="string">'-1'</span>}, {<span class="string">'min'</span>,<span class="string">'max'</span>});
0084         prob.modelsense = prob.osense;
0085         prob = rmfield(prob, {<span class="string">'osense'</span>});
0086     <span class="keyword">end</span>
0087     [prob.obj, prob.rhs] = deal(prob.c, prob.b);
0088     prob = rmfield(prob, {<span class="string">'c'</span>,<span class="string">'b'</span>});
0089     
0090     <span class="comment">%Rename intTol to IntFeasTol</span>
0091     <span class="keyword">if</span> milp
0092         solverparams.IntFeasTol = solverparams.intTol;
0093         solverparams  = rmfield(solverparams, {<span class="string">'intTol'</span>});
0094         prob.vtype = prob.vartype;
0095         prob  = rmfield(prob, {<span class="string">'vartype'</span>});
0096     <span class="keyword">end</span>
0097     
0098     resG = gurobi(prob,solverparams);
0099     
0100     <span class="keyword">try</span>
0101         [res.full, res.obj, res.origStat] = deal(resG.x,  resG.objval, resG.status);
0102         <span class="keyword">if</span> milp &amp;&amp; strcmp(resG.status, <span class="string">'TIME_LIMIT'</span>)
0103             <span class="comment">% If res has the objval field, it succeeded, regardless of</span>
0104             <span class="comment">% time_limit status</span>
0105             resG.status = <span class="string">'OPTIMAL'</span>;
0106         <span class="keyword">end</span>
0107         <span class="keyword">switch</span> resG.status
0108             <span class="keyword">case</span> <span class="string">'OPTIMAL'</span>
0109                 res.stat = 1;
0110             <span class="keyword">case</span> <span class="string">'UNBOUNDED'</span>
0111                 res.stat = 2;
0112             <span class="keyword">otherwise</span>
0113                 res.stat = 0;
0114         <span class="keyword">end</span>
0115         <span class="keyword">if</span> ~milp
0116             [res.vbasis, res.cbasis] = deal(resG.vbasis, resG.cbasis);
0117         <span class="keyword">else</span>
0118             res.mipgap = resG.mipgap; 
0119         <span class="keyword">end</span>
0120     <span class="keyword">catch</span>
0121         res.stat = 0;
0122         res.origStat = resG.status;  <span class="comment">% useful information to have</span>
0123     <span class="keyword">end</span>
0124     <span class="comment">%% Use GLPK using RAVEN-provided binary</span>
0125     <span class="keyword">case</span> <span class="string">'glpk'</span>
0126         solverparams.scale   = 128; <span class="comment">% Auto scaling</span>
0127         solverparams.tmlim   = defaultparams.timeLimit;
0128         solverparams.tolbnd  = defaultparams.feasTol;
0129         solverparams.toldj   = defaultparams.optTol;
0130         solverparams.tolint  = defaultparams.intTol;
0131         solverparams.tolobj  = defaultparams.objTol;
0132         solverparams.msglev  = 0; <span class="comment">% Level of verbosity</span>
0133         solverparams = <a href="#_sub1" class="code" title="subfunction s_merged=structUpdate(s_old,s_new)">structUpdate</a>(solverparams,params);
0134         
0135         prob.csense = <a href="#_sub2" class="code" title="subfunction paramlist = renameparams(paramlist,old,new)">renameparams</a>(prob.csense, {<span class="string">'L'</span>,<span class="string">'G'</span>,<span class="string">'E'</span>}, {<span class="string">'U'</span>,<span class="string">'L'</span>,<span class="string">'S'</span>});
0136         
0137         <span class="keyword">if</span> milp
0138             solverparams.tmlim   = solverparams.tmlim*10;
0139             solverparams.msglev  = 1; <span class="comment">% Level of verbosity</span>
0140             disp(<span class="string">'Issues have been observed when using GLPK for MILP solving. Be advised to carefully observe the results, or us another solver.'</span>)
0141         <span class="keyword">end</span>
0142         solverparams.scale   = 1; <span class="comment">% Auto scaling</span>
0143         
0144         <span class="comment">% Ensure that RAVEN glpk binary is used, return to original</span>
0145         <span class="comment">% directory afterwards</span>
0146         [ravenDir,currDir]=findRAVENroot();
0147         cd(fullfile(ravenDir,<span class="string">'software'</span>,<span class="string">'GLPKmex'</span>))
0148         [xopt, fmin, errnum, extra] = glpk(prob.c, prob.A, prob.b, prob.lb, prob.ub, prob.csense, prob.vartype, prob.osense, solverparams);
0149         cd(currDir)
0150         
0151         <span class="keyword">switch</span> errnum <span class="comment">% 1 = undefined; 2 = feasible; 3 = infeasible; 4 = no feasible solution; 5 = optimal; 6 = no unbounded solution</span>
0152             <span class="keyword">case</span> 5
0153                 res.stat = 1; <span class="comment">% Optimal</span>
0154             <span class="keyword">case</span> 2
0155                 res.stat = 2; <span class="comment">% Feasible, but not optimal</span>
0156             <span class="keyword">otherwise</span>
0157                 res.stat = 0;
0158         <span class="keyword">end</span>
0159         res.origStat = errnum;
0160         res.full     = xopt;
0161         res.obj      = fmin;
0162     <span class="keyword">otherwise</span>
0163         error(<span class="string">'RAVEN solver not defined or unknown. Try using setRavenSolver(''solver'').'</span>);
0164 <span class="keyword">end</span>
0165 <span class="keyword">if</span> res.stat&gt;0
0166     res.full=res.full(1:size(prob.a,2));
0167 <span class="keyword">end</span>
0168 <span class="keyword">end</span>
0169 
0170 <a name="_sub1" href="#_subfunctions" class="code">function s_merged=structUpdate(s_old,s_new)</a>
0171 <span class="comment">%Remove overlapping fields from first struct;</span>
0172 <span class="comment">%Obtain all unique names of remaining fields;</span>
0173 <span class="comment">%Merge both structs</span>
0174 s_merged = rmfield(s_old, intersect(fieldnames(s_old), fieldnames(s_new)));
0175 names = [fieldnames(s_merged); fieldnames(s_new)];
0176 s_merged = cell2struct([struct2cell(s_merged); struct2cell(s_new)], names, 1);
0177 <span class="keyword">end</span>
0178 
0179 <a name="_sub2" href="#_subfunctions" class="code">function paramlist = renameparams(paramlist,old,new)</a>
0180 <span class="keyword">if</span> ~iscell(paramlist)
0181     wasNoCell = true;
0182     paramlist={paramlist};
0183 <span class="keyword">else</span>
0184     wasNoCell = false;
0185 <span class="keyword">end</span>
0186 <span class="keyword">for</span> i=1:numel(old)
0187     paramlist = regexprep(paramlist,old{i},new{i});
0188 <span class="keyword">end</span>
0189 <span class="keyword">if</span> wasNoCell
0190     paramlist=paramlist{1};
0191 <span class="keyword">end</span>
0192 <span class="keyword">end</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>